set(wd)
setwd("~/")
get(~/)
get("~/"")
x
setwd("~/Documents/R - Cours/Stats_Infos/Devoir_3")
setwd("~/Documents/R - Cours/Stats_Infos/Devoir_3")
lpost_optim <- function(param){
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2))
}
#c) theta_n+1 chapeau= signaux_theta log f(...) où (...) est la matrice hessienne
#d) exp(a)/exp(b) = exp(a-b)
set.seed(2024)
X <- readRDS("Devoir3_data.RDS")
dim(X)
lpost <- function(theta, sig2, nu, tau2){
#k <- length(theta)
k <- 10 #nombre de lignes
ni <- 110 #nombre de colonnes
N <- sum(ni, na.rm = TRUE)
XiMoyen <- rowMeans(X, na.rm = T)
Xij2 <- sum(X^2, na.rm = T)
logf1 <- (N+8)/2 * log(sig2) - k/2 * log(tau2) - 1/sig2 - nu^2/2 - tau2
logf2 <- - 1/(2*tau2) * sum((theta - nu)^2, na.rm = T)
logf3 <- - 1/(2 * sig2) * (Xij2 - 2*sum(ni*XiMoyen*theta, na.rm = T) + sum(ni*theta^2, na.rm = T))
return(logf1+logf2+logf3)
}
lpost_optim <- function(param){
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2))
}
init_param <- c(rep(0, k), 1, 0, 1)
optim_results <- optim(init_param, lpost_optim, method = "L-BFGS-B")
print(optim_results$par)
optim_results <- optim(init_param, lpost_optim, method = "L-BFGS-B")
init_param <- c(rep(0, k), 1, 0, 1)
k <- 10 #nombre de lignes
ni <- 110 #nombre de colonnes
#k <- length(theta)
N <- sum(ni, na.rm = TRUE)
lpost <- function(theta, sig2, nu, tau2){
#k <- length(theta)
N <- sum(ni, na.rm = TRUE)
XiMoyen <- rowMeans(X, na.rm = T)
Xij2 <- sum(X^2, na.rm = T)
logf1 <- (N+8)/2 * log(sig2) - k/2 * log(tau2) - 1/sig2 - nu^2/2 - tau2
logf2 <- - 1/(2*tau2) * sum((theta - nu)^2, na.rm = T)
logf3 <- - 1/(2 * sig2) * (Xij2 - 2*sum(ni*XiMoyen*theta, na.rm = T) + sum(ni*theta^2, na.rm = T))
return(logf1+logf2+logf3)
}
lpost_optim <- function(param){
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2))
}
init_param <- c(rep(0, k), 1, 0, 1)
optim_results <- optim(init_param, lpost_optim, method = "L-BFGS-B")
print(optim_results$par)
optim_results <- optim(init_param, lpost_optim, method = "L-BFGS-B")
print(optim_results$value)
set.seed(2024)
X <- readRDS("Devoir3_data.RDS")
k <- 10 #nombre de lignes
ni <- 110 #nombre de colonnes
N = sum(110)
N
N <- k*ni
lpost <- function(theta, sig2, nu, tau2){
Xi_bar <- rowMeans(X, na.rm=TRUE)
sum_Xij2 <- sum(X^2, na.rm=TRUE)
# Calcul de la log densité a posteriori sans la constante K
log_f <- (-N/2) * log(sig2) - (k/2) * log(tau2) - (1/(2*sig2)) * sum_Xij2 +
(sum(ni*Xi_bar^2))/(2*sig2) - sum(ni*theta^2)/(2*sig2) +
sum(2*ni*Xi_bar*theta)/(2*sig2) - sum((theta - nu)^2)/(2*tau2) -
(nu^2)/(2*tau2) - (1/2)*log(sig2) - (1/2)*log(tau2) - (1/(2*sig2)) - (nu^2)/(2*tau2) - (1/tau2)
return(log_f)
}
set.seed(2024)
X <- readRDS("Devoir3_data.RDS")
k <- 10 #nombre de lignes
ni <- 110 #nombre de colonnes
N <- k*ni
lpost <- function(theta, sig2, nu, tau2){
Xi_bar <- rowMeans(X, na.rm=TRUE)
sum_Xij2 <- sum(X^2, na.rm=TRUE)
# Calcul de la log densité a posteriori sans la constante K
log_f <- (-N/2) * log(sig2) - (k/2) * log(tau2) - (1/(2*sig2)) * sum_Xij2 +
(sum(ni*Xi_bar^2))/(2*sig2) - sum(ni*theta^2)/(2*sig2) +
sum(2*ni*Xi_bar*theta)/(2*sig2) - sum((theta - nu)^2)/(2*tau2) -
(nu^2)/(2*tau2) - (1/2)*log(sig2) - (1/2)*log(tau2) - (1/(2*sig2)) - (nu^2)/(2*tau2) - (1/tau2)
return(log_f)
}
lpost_optim <- function(param) {
k <- length(param) - 3
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2)) # Négative car optim minimise par défaut
}
# Définition des paramètres initiaux, par exemple
init_param <- c(rep(0, k), 1, 0, 1) # k zéros pour theta, 1 pour sig2, 0 pour nu, 1 pour tau2
set.seed(2024)
X <- readRDS("Devoir3_data.RDS")
k <- 10 #nombre de lignes
ni <- 110 #nombre de colonnes
N <- k*ni
lpost <- function(theta, sig2, nu, tau2){
Xi_bar <- rowMeans(X, na.rm=TRUE)
sum_Xij2 <- sum(X^2, na.rm=TRUE)
# Calcul de la log densité a posteriori sans la constante K
log_f <- (-N/2) * log(sig2) - (k/2) * log(tau2) - (1/(2*sig2)) * sum_Xij2 +
(sum(ni*Xi_bar^2))/(2*sig2) - sum(ni*theta^2)/(2*sig2) +
sum(2*ni*Xi_bar*theta)/(2*sig2) - sum((theta - nu)^2)/(2*tau2) -
(nu^2)/(2*tau2) - (1/2)*log(sig2) - (1/2)*log(tau2) - (1/(2*sig2)) - (nu^2)/(2*tau2) - (1/tau2)
return(log_f)
}
lpost_optim <- function(param) {
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2)) # Négative car optim minimise par défaut
}
# Définition des paramètres initiaux, par exemple
init_param <- c(rep(0, k), 1, 0, 1) # k zéros pour theta, 1 pour sig2, 0 pour nu, 1 pour tau2
# Appel à la fonction optim
optim_results <- optim(init_param, lpost_optim, method = "L-BFGS-B") # Choix de la méthode dépend de la situation
# Affichage des résultats
print(optim_results$par) # Les paramètres estimés
print(optim_results$value) # La valeur de la fonction objectif
lpost <- function(theta, sig2, nu, tau2){
Xi_bar <- rowMeans(X, na.rm=TRUE)
sum_Xij2 <- sum(X^2, na.rm=TRUE)
# Calcul de la log densité a posteriori sans la constante K
log_f <- (-N/2) * log(sig2) - (k/2) * log(tau2) - (1/(2*sig2)) * sum_Xij2 +
sum((ni * Xi_bar^2)/(2*sig2), na.rm = TRUE) - sum((ni * theta^2)/(2*sig2), na.rm = TRUE) +
sum((2 * Xi_bar * theta)/sig2, na.rm = TRUE) - sum((theta - nu)^2)/(2*tau2) -
(nu^2)/(2*tau2) - (1/2)*log(sig2) - (1/2)*log(tau2) - (1/(2*sig2)) - (nu^2)/(2*tau2) - (1/tau2)
return(log_f)
}
lpost_optim <- function(param) {
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2)) # Négative car optim minimise par défaut
}
# Définition des paramètres initiaux, par exemple
init_param <- c(rep(0, k), 1, 0, 1) # k zéros pour theta, 1 pour sig2, 0 pour nu, 1 pour tau2
# Appel à la fonction optim
optim_results <- optim(init_param, lpost_optim, method = "L-BFGS-B") # Choix de la méthode dépend de la situation
# Utilisation de limites pour les paramètres dans optim
lower_bounds <- c(rep(-Inf, k), .Machine$double.eps, -Inf, .Machine$double.eps)
upper_bounds <- c(rep(Inf, k), Inf, Inf, Inf)
optim_results <- optim(
init_param,
lpost_optim,
method = "L-BFGS-B",
lower = lower_bounds,
upper = upper_bounds
)
print(lpost(rep(0, k), 1, 0, 1))
lpost <- function(theta, sig2, nu, tau2){
# Assurez-vous que 'X' est défini dans l'environnement global.
Xi_bar <- rowMeans(X, na.rm = TRUE)
sum_Xij2 <- sum(X^2, na.rm = TRUE)
# Calcul de la log densité a posteriori sans la constante K
log_f <- (-N/2) * log(sig2) - (k/2) * log(tau2) - (1/(2*sig2)) * sum_Xij2 +
sum((ni * Xi_bar^2)/(2*sig2), na.rm = TRUE) - sum((ni * theta^2)/(2*sig2), na.rm = TRUE) +
sum((2 * Xi_bar * theta)/sig2, na.rm = TRUE) - sum((theta - nu)^2)/(2*tau2) -
(nu^2)/(2*tau2) - (1/2)*log(sig2) - (1/2)*log(tau2) - (1/(2*sig2)) - (nu^2)/(2*tau2) - (1/tau2)
return(log_f)
}
lpost_optim <- function(param) {
theta <- param[1:k]
sig2 <- param[k+1]
nu <- param[k+2]
tau2 <- param[k+3]
return(-lpost(theta, sig2, nu, tau2))
}
init_param <- c(rep(0, k), 1, 0, 1)
opt <- optim(init_param, lpost_optim, method = "L-BFGS-B")
View(X)
init_param <- c(rep(0, k), 1, 0, 1)
lower_bounds <- c(rep(-Inf, k), 1e-6, -Inf, 1e-6)
upper_bounds <- rep(Inf, k+3)
opt <- optim(init_param, lpost_optim, method = "L-BFGS-B")
print(lpost(init_param[1:k], init_param[k+1], init_param[k+2], init_param[k+3]))
initial_values <- c(rep(0, k), 1, 0, 1) # Replace with your actual initial values
optim_results <- optim(par = initial_values, fn = lpost_optim)
View(X)
