---
title: "Devoir2"
author: "René Picard"
date: "2024-02-13"
output: pdf_document
---

le seed
```{r}
set.seed(20240220)
```



# Question 1

On génère la matrice de covariance $\Sigma$
```{r}
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100


for(i in 1:100){
  for(j in 1:100){
    V[i,j] <- 5 * 0.8^(abs(i-j))
  }
}

```


## (a)

On écrit une fonction ma_chol


```{r}
ma_chol <- function(cov_mat) {
  n <- nrow(cov_mat)#pour connaitre la dimension de la matrice
  L <- matrix(0, n, n)#on initialise la matrice
  
  #ici on calcul les colonne en dernier et les lignes en premier
  for (k in 1:n) {
    for (j in 1:n) {
      #ici on calcul l'élément L_kk du théorème
      if(j == k){
        L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
      }
      
      #calcul de l'élément L_jk du théorème
      if (j > k) {
        L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
      }
    }
  }
  return(L)
}
```


## (b)

On utilise notre fonction ma_chol avec la matrice $V$ créé plus juste après la question 1 (donc on n'implémentera pas l'indice qui aurait été utile si j'avais lu les questions avant de commencer l'exercices...)
```{r}
L_chol <- ma_chol(V)
```


## (c)

On prend le code de la fonction de Box-Muller fournit dans les notes de cours pour générer des valeurs qui suivent la loi normale $N(0,1)$

```{r}
box_muller <- function(n){
  
  m <- 2*ceiling(n/2) # le vrai nombre (pair) de réalisations uniformes nécessaire
  u <- runif(m)
  valeurs <- rep(0, m)
  for(i in 1:(m/2)){
    
    r <- sqrt(-2*log(u[2*(i-1)+1]))
    t <- 2*pi*u[2*(i-1)+2]
    
    valeurs[2*(i-1)+1] <- r*cos(t)
    valeurs[2*(i-1)+2] <- r*sin(t)
    
  }
  
  return(valeurs[1:n])
  
}
```


Ensuite on utilise la fonction suivante pour généré des valeurs qui suivent une loi normale $N(0,1)$, et on en génère 5000. Une fois fait, on multiplie la matrice $Z$, et on la multiplie avec la matrice résultante de la décomposition de Cholesky

```{r}
n <- 5000
d <- dim(L_chol)[1]
z <- matrix(nrow = n, ncol = d)
for(i in 1:n){
  z[i,] <- box_muller(d)  
}
x <- z %*% L_chol
```


## (d)


Tout d'abord on estime $\theta$ par la méthode de Monte Carlo. Nous avons déjà généré nos 100 observations indépendantes (nommé x) au (c). Nous allons donc calculer $m(X)$

```{r}
m <- function(X) {
  return(exp(max(X)))
}
```
Et ensuite on calcul la moyenne pour obtenir l'estimateur de Monte Carlo
```{r}
theta_chap <- mean(apply(x, 1, m))
```
Maintenant on estime sigma

```{r}

```





# Question 2

## (a)




