for(k in 1:n){
#on calcul L_kk
temp_sum <- 0
if(k > 1) {
temp_sum <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k,k] <- sqrt(mat_cov[k,k] - temp_sum)
for(j in (k+1):n){
# on calcul L_jk
if(chol1[k,k] > 0){
temp_sum <- sum(chol1[j, 1:(k-1)]* chol1[k, 1:(k-1)])
}
}
}
return(chol1)
}
ma_chol(V)
ma_chol <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, n, n) # initialisation de la matrice de Cholesky
for (k in 1:n) {
# Calcul de L_kk
temp_sum <- 0
if (k > 1) {
temp_sum <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - temp_sum)
for (j in (k+1):n) {
# Calcul de L_jk
if (chol1[k, k] > 0) {
temp_sum <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
chol1[j, k] <- (mat_cov[j, k] - temp_sum) / chol1[k, k]
}
}
}
return(chol1)
}
ma_chol(V)
ma_chol <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
if (chol1[k, k] > 0) {
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
}
return(chol1)
}
ma_chol(V)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
if (chol1[k, k] > 0) {
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
}
return(chol1)
}
ma_chol2(V)
set.seed(20240220)
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100
V
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
V
ma_chol <- function(mat_cov){
n <- dim(mat_cov)[1]
chol1 <- matrix(0, nrow = n, ncol = n)
#on calcul L_kk
for(k in 1:n){
#on calcul L_kk
temp_sum <- 0
if(k > 1) {
temp_sum <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k,k] <- sqrt(mat_cov[k,k] - temp_sum)
for(j in (k+1):n){
# on calcul L_jk
if(chol1[k,k] > 0){
temp_sum <- sum(chol1[j, 1:(k-1)]* chol1[k, 1:(k-1)])
}
}
}
return(chol1)
}
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
if (chol1[k, k] > 0) {
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
}
return(chol1)
}
ma_chol2(V)
```{r}
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky
for (k in 1:n) {
# Calcul de L_kk
sum_k <- ifelse(k > 1, sum(chol1[k, 1:(k-1)]^2), 0)
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
# Continuer seulement si L_kk est positif
if (chol1[k, k] > 0) {
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- ifelse(k > 1, sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)]), 0)
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
}
return(chol1)
}
ma_chol2(V)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
if (chol1[k, k] > 0) {
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
}
return(chol1)
}
ma_chol2(V)
is.positive.definite(as.matrix(V))
install.packages('Matrix')
library(Matrix)
is.positive.definite(as.matrix(V))
is.positive.definite(as.matrix(V))
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- sum(chol1[k, 1:(k-1)]^2)
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
# S'assurer que la racine carrée n'est pas de nombre imaginaire
if (chol1[k, k] <= 0) {
stop("La matrice n'est pas définie positive.")
}
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
ma_chol2(V)
ma_chol2(matrix(c(1,2,3,4,5,6,7,8,9), nrow = 3, ncol = 3))
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
all(eigen_values > 0)
eigen_values <- eigen(V)$values
all(eigen_values > 0)
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
return(chol1)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
j <- k+1
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
print(k)
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
#print(k)
for (j in (k+1):n) {
print(j)
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
#print(k)
for (j in (k+1):n) {
print(j)
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
# sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
ma_chol2 <- function(mat_cov) {
n <- dim(mat_cov)[1] # la dimension de la matrice
chol1 <- matrix(0, nrow = n, ncol = n) # initialisation de la matrice de Cholesky à zéro
for (k in 1:n) {
# Calcul de L_kk
sum_k <- 0
if (k > 1) {
sum_k <- sum(chol1[k, 1:(k-1)]^2)
}
chol1[k, k] <- sqrt(mat_cov[k, k] - sum_k)
for (j in (k+1):n) {
# Calcul de L_jk
sum_jk <- 0
if (k > 1) {
print(k)
print(j)
sum_jk <- sum(chol1[j, 1:(k-1)] * chol1[k, 1:(k-1)])
}
chol1[j, k] <- (mat_cov[j, k] - sum_jk) / chol1[k, k]
}
}
return(chol1)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol2(mat_test)
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100
V
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
V
# Fonction pour la décomposition de Cholesky
ma_chol <- function(cov_matrix) {
n <- nrow(cov_matrix)
L <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:i) {
sum <- 0
if (j > 1) {
sum <- sum(L[i, 1:(j-1)] * L[j, 1:(j-1)])
}
if (i == j) {
L[i, j] <- sqrt(pmax(cov_matrix[i, i] - sum, 0))
} else {
L[i, j] <- (1 / L[j, j]) * (cov_matrix[i, j] - sum)
}
}
}
return(L)
}
# Créer la matrice de covariance Sigma
exposants <- abs(outer(1:100, 1:100, FUN = "-"))
Sigma <- 5 * 0.8^exposants
# Appliquer la décomposition de Cholesky à la matrice Sigma
L <- ma_chol(Sigma)
# Afficher une petite partie de la matrice L pour vérification
L[1:5, 1:5]
ma_chol(V)
ma_chol(matrix(c(4,12,-16,12,37,-43,-16,-43,98), nrow=3, ncol = 3, byrow = T))
# Fonction pour la décomposition de Cholesky
ma_chol <- function(cov_matrix) {
n <- nrow(cov_matrix)
L <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:i) {
somme <- 0
if (j > 1) {
somme <- sum(L[i, 1:(j-1)] * L[j, 1:(j-1)])
}
if (i == j) {
L[i, j] <- sqrt(pmax(cov_matrix[i, i] - somme, 0))
} else {
L[i, j] <- (1 / L[j, j]) * (cov_matrix[i, j] - somme)
}
}
}
return(L)
}
ma_chol(matrix(c(4,12,-16,12,37,-43,-16,-43,98), nrow=3, ncol = 3, byrow = T))
ma_chol <- function(cov_matrix) {
n <- nrow(cov_matrix)
L <- matrix(0, n, n)
for (i in 1:n) {
for (j in 1:i) {
somme <- 0
if (j > 1) {
somme <- sum(L[i, 1:(j-1)] * L[j, 1:(j-1)])
}
if (i == j) {
L[i, j] <- sqrt(pmax(cov_matrix[i, i] - somme, 0))
} else {
L[i, j] <- (1 / L[j, j]) * (cov_matrix[i, j] - somme)
}
}
}
return(L)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol(mat_test)
ma_chol(V)
ma_chol_col_by_col <- function(cov_matrix) {
n <- nrow(cov_matrix)
L <- matrix(0, n, n)
for (j in 1:n) {
# Calcul de L_jj
somme_diag <- sum(L[j, 1:(j-1)]^2)
L[j, j] <- sqrt(pmax(cov_matrix[j, j] - somme_diag, 0))
for (i in (j+1):n) {
# Calcul de L_ij
if (L[j, j] > 0) {
somme_off_diag <- sum(L[i, 1:(j-1)] * L[j, 1:(j-1)])
L[i, j] <- (cov_matrix[i, j] - somme_off_diag) / L[j, j]
}
}
}
return(L)
}
ma_chol_col_by_col(matrix(c(4,12,-16,12,37,-43,-16,-43,98), nrow=3, ncol = 3, byrow = T))
ma_chol2 <- function(cov_mat) {
n <- nrow(cov_mat)
L <- matrix(0, n, n)
for (k in 1:n) {
for (j in 1:n) {
if(j == k){
L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
}
if (j > k) {
L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
}
}
}
return(L)
}
ma_chol(matrix(c(4,12,-16,12,37,-43,-16,-43,98), nrow=3, ncol = 3, byrow = T))
ma_chol2(matrix(c(4,12,-16,12,37,-43,-16,-43,98), nrow=3, ncol = 3, byrow = T))
ma_chol <- function(cov_mat) {
n <- nrow(cov_mat)#pour connaitre la dimension de la matrice
L <- matrix(0, n, n)#on initialise la matrice
#ici on calcul les colonne en dernier et les lignes en premier
for (k in 1:n) {
for (j in 1:n) {
#ici on calcul l'élément L_kk du théorème
if(j == k){
L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
}
#calcul de l'élément L_jk du théorème
if (j > k) {
L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
}
}
}
return(L)
}
# Testons avec une petite matrice définie positive
mat_test <- matrix(c(4, 1, 1, 3), nrow=2, ncol=2)
ma_chol(mat_test)
ma_chol(V)
ma_chol(V)
L <- ma_chol(V)
all.equal(t(L) %*% L, V)
identique <- all.equal(t(L) %*% L, V)
identique
ma_chol(V)
