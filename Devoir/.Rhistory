set(wd)
setwd("~/")
get(~/)
get("~/"")
x
setwd("~/Documents/R/Stats_Infos/Devoir")
setwd("~/Documents/R/Stats_Infos/Devoir")
set.seed(20240220)
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
ma_chol <- function(cov_mat) {
n <- nrow(cov_mat)#pour connaitre la dimension de la matrice
L <- matrix(0, n, n)#on initialise la matrice
#ici on calcul les colonne en dernier et les lignes en premier
for (k in 1:n) {
for (j in 1:n) {
#ici on calcul l'élément L_kk du théorème
if(j == k){
L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
}
#calcul de l'élément L_jk du théorème
if (j > k) {
L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
}
}
}
return(L)
}
L_chol <- ma_chol(V)
box_muller <- function(n){
m <- 2*ceiling(n/2) # le vrai nombre (pair) de réalisations uniformes nécessaire
u <- runif(m)
valeurs <- rep(0, m)
for(i in 1:(m/2)){
r <- sqrt(-2*log(u[2*(i-1)+1]))
t <- 2*pi*u[2*(i-1)+2]
valeurs[2*(i-1)+1] <- r*cos(t)
valeurs[2*(i-1)+2] <- r*sin(t)
}
return(valeurs[1:n])
}
n <- 5000
d <- dim(L_chol)[1]
z <- matrix(nrow = n, ncol = d)
for(i in 1:n){
z[i,] <- box_muller(d)
}
x <- z %*% L_chol
m <- function(X) {
return(exp(max(X)))
}
theta_chap <- mean(apply(x, 1, m))
sigma_hat <- sd(exp(apply(x, 1, m)))
set.seed(20240220)
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
ma_chol <- function(cov_mat) {
n <- nrow(cov_mat)#pour connaitre la dimension de la matrice
L <- matrix(0, n, n)#on initialise la matrice
#ici on calcul les colonne en dernier et les lignes en premier
for (k in 1:n) {
for (j in 1:n) {
#ici on calcul l'élément L_kk du théorème
if(j == k){
L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
}
#calcul de l'élément L_jk du théorème
if (j > k) {
L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
}
}
}
return(L)
}
L_chol <- ma_chol(V)
box_muller <- function(n){
m <- 2*ceiling(n/2) # le vrai nombre (pair) de réalisations uniformes nécessaire
u <- runif(m)
valeurs <- rep(0, m)
for(i in 1:(m/2)){
r <- sqrt(-2*log(u[2*(i-1)+1]))
t <- 2*pi*u[2*(i-1)+2]
valeurs[2*(i-1)+1] <- r*cos(t)
valeurs[2*(i-1)+2] <- r*sin(t)
}
return(valeurs[1:n])
}
n <- 5000
d <- dim(L_chol)[1]
z <- matrix(nrow = n, ncol = d)
for(i in 1:n){
z[i,] <- box_muller(d)
}
x <- z %*% L_chol
m <- function(X) {
return(exp(max(X)))
}
theta_chap <- mean(apply(x, 1, m))
sigma_hat <- sd(exp(apply(x, 1, m)))
z_alpha_2 <- qnorm(1 - 0.05/2)
interval <- c(
theta_hat - z_alpha_2 * sigma_hat / sqrt(n), theta_hat + z_alpha_2 * sigma_hat / sqrt(n))
interval <- c(
theta_hat - z_alpha_2 * sigma_hat / sqrt(n), theta_hat + z_alpha_2 * sigma_hat / sqrt(n))
set.seed(20240220)
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
ma_chol <- function(cov_mat) {
n <- nrow(cov_mat)#pour connaitre la dimension de la matrice
L <- matrix(0, n, n)#on initialise la matrice
#ici on calcul les colonne en dernier et les lignes en premier
for (k in 1:n) {
for (j in 1:n) {
#ici on calcul l'élément L_kk du théorème
if(j == k){
L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
}
#calcul de l'élément L_jk du théorème
if (j > k) {
L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
}
}
}
return(L)
}
L_chol <- ma_chol(V)
box_muller <- function(n){
m <- 2*ceiling(n/2) # le vrai nombre (pair) de réalisations uniformes nécessaire
u <- runif(m)
valeurs <- rep(0, m)
for(i in 1:(m/2)){
r <- sqrt(-2*log(u[2*(i-1)+1]))
t <- 2*pi*u[2*(i-1)+2]
valeurs[2*(i-1)+1] <- r*cos(t)
valeurs[2*(i-1)+2] <- r*sin(t)
}
return(valeurs[1:n])
}
n <- 5000
d <- dim(L_chol)[1]
z <- matrix(nrow = n, ncol = d)
for(i in 1:n){
z[i,] <- box_muller(d)
}
x <- z %*% L_chol
m <- function(X) {
return(exp(max(X)))
}
theta_hat <- mean(apply(x, 1, m))
sigma_hat <- sd(exp(apply(x, 1, m)))
z_alpha_2 <- qnorm(1 - 0.05/2)
interval <- c(
theta_hat - z_alpha_2 * sigma_hat / sqrt(n), theta_hat + z_alpha_2 * sigma_hat / sqrt(n))
interval
z_alpha_2
sigma_hat
theta_hat
x
sigma_hat <- sd(exp(apply(x, 1, max)))
sigma_hat <- sd(exp(apply(x, 1, max)))
sigma_hat
sigma_hat <- sd(exp(apply(x, 1, m)))
sigma_hat
theta_hat <- mean(apply(x, 1, m))
theta_hat
sigma_hat <- sd(exp(apply(x, 1, max)))
theta_hat <- mean(apply(x, 1, max))
theta_hat
sigma_hat <- sd(exp(apply(x, 1, max)))
sigma_hat
interval <- c(
theta_hat - z_alpha_2 * sigma_hat / sqrt(n), theta_hat + z_alpha_2 * sigma_hat / sqrt(n))
interval
