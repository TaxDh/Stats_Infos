setwd("~/Documents/R/Stats_Infos/Devoir")
le seed
# Question 1
set.seed(20240220)
V = matrix(nrow = 100, ncol = 100, byrow = T)#car 100 fois 100
V
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
V
for(i in 1:100){
for(j in 1:100){
V[i,j] <- 5 * 0.8^(abs(i-j))
}
}
ma_chol <- function(cov_mat) {
n <- nrow(cov_mat)#pour connaitre la dimension de la matrice
L <- matrix(0, n, n)#on initialise la matrice
#ici on calcul les colonne en dernier et les lignes en premier
for (k in 1:n) {
for (j in 1:n) {
#ici on calcul l'élément L_kk du théorème
if(j == k){
L[k,k] <- sqrt(cov_mat[k,k]- sum(L[k, 1:(k-1)]^2))
}
#calcul de l'élément L_jk du théorème
if (j > k) {
L[j,k] <- (1/L[k,k])*(cov_mat[j,k] - sum(L[j, 1:(k-1)]*L[k, 1:(k-1)]))
}
}
}
return(L)
}
L_chol <- ma_chol(V)
L_chol
L_chol <- ma_chol(V)
box_muller <- function(n){
m <- 2*ceiling(n/2) # le vrai nombre (pair) de réalisations uniformes nécessaire
u <- runif(m)
valeurs <- rep(0, m)
for(i in 1:(m/2)){
r <- sqrt(-2*log(u[2*(i-1)+1]))
t <- 2*pi*u[2*(i-1)+2]
valeurs[2*(i-1)+1] <- r*cos(t)
valeurs[2*(i-1)+2] <- r*sin(t)
}
return(valeurs[1:n])
}
n <- 5000
d <- dim(L_chol)[1]
z <- matrix(nrow = n, ncol = d)
for(i in 1:n){
z[i,] <- box_muller(d)
}
x <- z %*% L_chol
m <- exp(max(x))
m
theta_chap <- mean(apply(x, 1, m))
m <- function(X) {
return(exp(max(X)))
}
theta_chap <- mean(apply(x, 1, m))
theta_chap
# exemple: estimation Monte Carlo d'une intégrale sur (0, 1), page 5
th <- sqrt(pi)/2
n <- 100
ech <- runif(n) # création des xi selon la loi uniforme
th_hat <- mean(sqrt(-log(ech))) #la formule dans l'ex page 5
th_hat
# vérification de la nortmalité asymptotique
z <- replicate(1000, {
ech <- runif(n)
th_hat <- mean(sqrt(-log(ech)))
sig_hat <- sd(sqrt(-log(ech)))
return(sqrt(n) * (th_hat - th)/sig_hat)
})
plot(density(z))
# vérification de la couverture de l'intervalle de confiance
alpha <- .1
couv <- replicate(1000, {
ech <- runif(n)
th_hat <- mean(sqrt(-log(ech)))
sig_hat <- sd(sqrt(-log(ech)))
return(
(th_hat - qnorm(alpha/2, lower.tail=FALSE) * sig_hat / sqrt(n) <= th) && (th_hat + qnorm(alpha/2, lower.tail=FALSE) * sig_hat / sqrt(n) >= th)
)
})
# couv
mean(couv)
# exemple: estimation Mont Carlo d'une somme page 6
# estimation numérique de theta
test <- sapply(1:100, function(n) sum( abs(cos(0:n))/factorial(0:n) ))
plot(test) # on voit que la somme partielle est bien stabilisée après avoir sommé les dix premiers termes
plot(test[2:100] - test[1:99], log="y")
th <- test[100]
n <- 1000
ech <- rpois(n, 1)
th_hat <- exp(1) * mean(abs(cos(ech)))
th_hat
# vérification de la nortmalité asymptotique
z <- replicate(1000, {
ech <- rpois(n, 1)
th_hat <- exp(1) * mean(abs(cos(ech)))
sig_hat <- exp(1) * sd(abs(cos(ech)))
return(sqrt(n) * (th_hat - th)/sig_hat)
})
plot(density(z))
# vérification de la couverture de l'intervalle de confiance
alpha <- .05
couv <- replicate(1000, {
ech <- rpois(n, 1)
th_hat <- exp(1) * mean(abs(cos(ech)))
sig_hat <- exp(1) * sd(abs(cos(ech)))
return(
(th_hat - qnorm(alpha/2, lower.tail=FALSE) * sig_hat / sqrt(n) <= th) && (th_hat + qnorm(alpha/2, lower.tail=FALSE) * sig_hat / sqrt(n) >= th)
)
})
# couv
mean(couv)
# exemple: estimation Mont Carlo d'une espérance par rapport à une loi normale multivariée
# algorithme de génération de normales multivariées
# entrées: taille échantillonnale n, vecteur de moyennes mu, matrice de covariance Sig
normalemulti <- function(n, mu, Sig){
if(length(mu) != nrow(Sig)) stop("Les dimensions de mu et Sig ne sont pas compatibles")
d <- length(mu)
L <- t(chol(Sig))#chol est la decomposition de cholesky
z <- matrix(rnorm(n*d), nrow=n)
return(t(apply(z, 1, function(x) mu + L %*% x)))
}
# exemple
mu <- rep(0, 2)
Sig <- matrix(c(1, -.8, -.8, 1), 2, 2)
ech <- normalemulti(1000, mu, Sig)
plot(ech[,1], ech[,2], xlim=c(-3, 3), ylim=c(-3, 3))
# simulation
th <- ???
n <- 100
# représentation graphique du plancher et initialisation
nlattes <- 6
plot(NULL, xlim=c(0, nlattes), ylim=c(0, nlattes), xlab="", ylab="")
for(i in 0:nlattes){
lines(c(-nlattes, nlattes+1), rep(i, 2), col=4, lw=3)
}
n <- 0
n_succ <- 0
# génération de la position du centre de l'aiguille et de son angle
x <- nlattes*runif(2)
theta <- pi*runif(1)
# calcul des deux extrémités de l'aiguille
tete <- x - c(cos(theta), sin(theta)) / 2
pointe <- x + c(cos(theta), sin(theta)) / 2
# incrémentation
n <- n+1
# code de couleur: rouge si l'aiguille traverse une ligne, noir sinon
coul <- "black"
if( floor(tete[2]) != floor(pointe[2]) ){
n_succ <- n_succ+1
coul <- "red"
}
# représentation graphique de l'aiguille
lines(c(x[1] - cos(theta)/2, x[1] + cos(theta)/2),
c(x[2] - sin(theta)/2, x[2] + sin(theta)/2),
col=coul, lw=2)
# estimation de pi mise à jour
2*n/n_succ
# automatisation
for(i in 1:1000){
# génération de la position du centre de l'aiguille et de son angle
x <- nlattes*runif(2)
theta <- pi*runif(1)
# calcul des deux extrémités de l'aiguille
tete <- x - c(cos(theta), sin(theta)) / 2
pointe <- x + c(cos(theta), sin(theta)) / 2
# incrémentation
n <- n+1
# code de couleur: rouge si l'aiguille traverse une ligne, noir sinon
coul <- "black"
if( floor(tete[2]) != floor(pointe[2]) ){
n_succ <- n_succ+1
coul <- "red"
}
# représentation graphique de l'aiguille
lines(c(x[1] - cos(theta)/2, x[1] + cos(theta)/2),
c(x[2] - sin(theta)/2, x[2] + sin(theta)/2),
col=coul, lw=2)
}
# estimation de pi mise à jour
2*n/n_succ
